# WMMT Controller Server 测试文档

## 测试文件概述

### 1. keyboard.test.ts - 键盘输出测试

#### 测试目标
验证键盘输入状态到系统按键的转换功能，确保按键操作的正确性、幂等性和异常处理。测试关注于验证 KeyDown/KeyUp 行为，而非具体的实现细节。

#### 测试环境设置
- **测试框架**：Jest
- **模拟库**：使用 `jest.mock` 模拟 `node-key-sender` 库的 `sendKey` 函数
- **测试对象**：`KeyboardExecutor` 类

#### 测试用例与流程

| 测试用例编号 | 测试用例名称 | 测试逻辑 | 预期结果 |
|--------------|--------------|----------|----------|
| 1 | 单个按键按下测试 | 1. 初始状态为空<br>2. 应用包含单个按键（'W'）的输入状态 | 发送 `KeyDown('W')` 事件 |
| 2 | 多个按键按下测试 | 1. 初始状态为空<br>2. 应用包含多个按键（'W'、'A'）的输入状态 | 发送 `KeyDown('W')` 和 `KeyDown('A')` 事件 |
| 3 | 按键释放测试 | 1. 初始状态为 ['W']<br>2. 应用包含按键 'A' 的输入状态 | 发送 `KeyUp('W')` 和 `KeyDown('A')` 事件 |
| 4 | 重置功能测试 | 1. 初始状态为 ['W']<br>2. 调用 `reset` 方法 | 发送 `KeyUp('W')` 事件，最终状态为空 |
| 5 | 幂等性测试 | 重复两次应用相同的输入状态 | 仅第一次应用时发送按键事件，第二次应用不产生任何输出（真幂等性） |
| 6 | 空状态处理测试 | 1. 初始状态为空<br>2. 应用空的输入状态 | 不发送任何按键事件 |
| 7 | 顺序按键测试 | 按顺序应用：<br>1. 按键 'W'<br>2. 按键 'W' 和 'A'<br>3. 按键 'A'<br>4. 空状态 | 发送预期的 KeyDown/KeyUp 事件序列 |
| 8 | 键盘状态初始化测试 | 初始化 KeyboardExecutor 并检查初始状态 | 初始状态为空，不发送任何按键事件 |

### 2. startup.test.ts - 启动阶段测试

#### 测试目标
验证服务器组件的初始化和关闭流程，确保各组件能正确启动和停止，并验证 ApplyScheduler 的实际 tick 行为。

#### 测试环境设置
- **测试框架**：Jest
- **测试对象**：WebSocket服务器、输入执行器、状态存储、应用调度器
- **清理策略**：每个测试后停止所有组件

#### 测试用例与流程

| 测试用例编号 | 测试用例名称 | 测试逻辑 | 预期结果 |
|--------------|--------------|----------|----------|
| 1 | 组件初始化测试 | 1. 启动 WebSocket 服务器<br>2. 启动输入执行器<br>3. 初始化状态存储<br>4. 获取执行器管理器<br>5. 初始化并启动应用调度器 | 所有组件成功初始化，执行器管理器存在，调度器运行中 |
| 2 | 组件关闭测试 | 1. 启动所有组件<br>2. 验证调度器运行状态<br>3. 停止所有组件 | 所有组件成功停止，调度器不再运行 |
| 3 | 状态存储初始化测试 | 创建 StateStore 实例，检查初始状态 | 初始状态为 null |
| 4 | 应用调度器初始化测试 | 初始化并启动 ApplyScheduler | 调度器成功启动，运行状态为 true |
| 5 | 调度器 tick 行为测试 | 1. 初始化并启动 ApplyScheduler（使用短间隔）<br>2. 添加 tick 回调记录 tick 数<br>3. 等待一段时间<br>4. 停止调度器<br>5. 验证 tick 计数 | 记录的 tick 数符合预期间隔（至少 3 个 tick） |

### 3. state.test.ts - 状态更新与覆盖测试

#### 测试环境设置
- **测试框架**：Jest
- **测试对象**：StateStore、ApplyScheduler
- **全局设置**：在所有测试前启动 WebSocket 服务器和输入执行器
- **全局清理**：在所有测试后停止所有组件

#### 测试用例与流程

| 测试用例编号 | 测试用例名称 | 测试逻辑 | 预期结果 |
|--------------|--------------|----------|----------|
| 1 | 状态存储与检索测试 | 1. 存储第一个状态（按键 'W'）<br>2. 存储第二个状态（按键 'A'）<br>3. 检索最新状态 | 1. 第一个状态成功存储<br>2. 第二个状态成功存储<br>3. 检索到的最新状态为第二个状态 |
| 2 | 序列号处理测试 | 1. 存储序列号为 100 的状态<br>2. 存储序列号为 101 的状态<br>3. 存储序列号为 100 的状态（重复） | 1. 序列号 100 的状态成功存储<br>2. 序列号 101 的状态成功存储<br>3. 重复的序列号 100 状态被拒绝 |
| 3 | 缺失字段处理测试 | 1. 存储包含所有字段的完整状态<br>2. 存储仅包含键盘字段的部分状态 | 部分状态成功存储，缺失字段被默认值填充 |
| 4 | 空状态重置测试 | 1. 存储初始状态（按键 'W'）<br>2. 存储空状态 | 空状态成功存储，替换了初始状态 |
| 5 | 无效状态处理测试 | 1. 存储缺少必填字段的状态<br>2. 存储包含非数字 frameId 的状态<br>3. 存储缺少 frameId 的状态 | 1. 缺少必填字段的状态被拒绝<br>2. 非数字 frameId 状态被拒绝<br>3. 缺少 frameId 的状态被拒绝 |

### 4. websocket.test.ts - WebSocket 连接测试

#### 测试目标
验证 WebSocket 服务器的连接管理功能，包括连接建立、并发连接、断开处理、重连和消息响应，以及关键的断连→清零安全机制。

#### 测试环境设置
- **测试框架**：Jest
- **测试对象**：WebSocket 服务器
- **测试工具**：自定义 WsClient 类
- **环境设置**：在所有测试前启动 WebSocket 服务器，获取实际端口

#### 测试用例与流程

| 测试用例编号 | 测试用例名称 | 测试逻辑 | 预期结果 |
|--------------|--------------|----------|----------|
| 1 | 连接建立测试 | 创建 WebSocket 客户端，调用 connect 方法 | 连接成功建立，不抛出异常 |
| 2 | 并发连接测试 | 同时创建并连接 3 个 WebSocket 客户端 | 所有客户端成功连接，不抛出异常 |
| 3 | 优雅断开测试 | 1. 创建并连接客户端<br>2. 监听 close 事件<br>3. 关闭客户端 | 客户端成功断开，close 事件被触发 |
| 4 | 重新连接测试 | 1. 创建并连接客户端<br>2. 关闭客户端<br>3. 重新连接 | 客户端成功重新连接，不抛出异常 |
| 5 | Ping/Pong 响应测试 | 1. 创建并连接客户端<br>2. 监听 pong 消息<br>3. 发送 ping 消息 | 客户端接收到 pong 消息响应 |
| 6 | 断连→清零测试 | 1. 创建并连接客户端<br>2. 发送包含按键状态的消息<br>3. 断开客户端连接<br>4. 验证输入状态被重置为安全状态 | 连接断开后，输入状态被重置为默认安全状态（所有按键释放） |

## 测试工具与辅助类

### 1. TestUtils 类
- **文件路径**：`tests/common/testUtils.ts`
- **主要功能**：提供测试状态创建方法，明确区分完整状态和子状态
- **核心方法**：
  - `createMinimalInputState()`：创建最小化的 InputState 对象（无 frameId）
  - `createCompleteInputState(frameId, overrides)`：创建完整的 InputState 对象
  - `createKeyboardSubState(pressedKeys)`：创建键盘子状态
  - `createMouseSubState(overrides)`：创建鼠标子状态
  - `createJoystickSubState(overrides)`：创建摇杆子状态
  - `createGyroscopeSubState(overrides)`：创建陀螺仪子状态
  - `createTestStateWithKeyboard(frameId, pressedKeys, overrides)`：创建带有特定键盘按键的测试状态

### 2. WsClient 类
- **文件路径**：`tests/common/wsClient.ts`
- **主要功能**：WebSocket 客户端测试工具
- **核心方法**：
  - `connect()`：建立 WebSocket 连接
  - `send(message)`：发送 WebSocket 消息
  - `close()`：关闭 WebSocket 连接
  - `onMessage(handler)`：监听 WebSocket 消息
  - `onClose(handler)`：监听连接关闭事件

## 测试执行流程

### 1. 单个测试文件执行
```bash
npm test -- tests/cases/keyboard.test.ts
```

### 2. 所有测试文件执行
```bash
npm test
```

### 3. 测试覆盖率报告
```bash
npm run test:coverage
```

## 测试环境要求

1. **Node.js 版本**：22.x 或更高
2. **依赖库**：
   - jest
   - ts-jest
   - @types/jest
   - node-key-sender (模拟)
3. **操作系统**：Windows (依赖 node-key-sender)

## 测试最佳实践

1. **隔离性**：每个测试用例独立运行，互不影响
2. **清理策略**：测试后清理资源，避免资源泄漏
3. **模拟依赖**：使用 mock 替代外部依赖，确保测试稳定性
4. **幂等性**：确保测试可以重复执行，结果一致
5. **覆盖边界情况**：测试正常、异常和边界条件

## 测试结果分析

| 测试文件 | 测试用例数量 | 通过率 |
|----------|--------------|--------|
| keyboard.test.ts | 8 | 100% |
| startup.test.ts | 5 | 100% |
| state.test.ts | 5 | 100% |
| websocket.test.ts | 6 | 100% |

## 测试改进建议

1. **增加集成测试**：测试组件间的交互
2. **增加性能测试**：测试高负载下的系统表现
3. **增加安全测试**：测试输入验证和边界情况
4. **增加 E2E 测试**：测试完整的端到端流程
5. **增加持续集成**：自动化测试和覆盖率报告

## 结论

服务器的测试套件覆盖了核心功能，包括键盘输出、组件启动关闭、状态管理和 WebSocket 连接。所有测试用例均通过，表明系统的核心功能正常工作。测试框架设计合理，使用了模拟和隔离策略，确保测试的可靠性和稳定性。
